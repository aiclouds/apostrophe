/* stylelint-disable */
<template>
  <div :data-apos-area="areaId" class="apos-area">
    <div
      v-if="next.length === 0"
      class="apos-empty-area"
    >
      <AposEmptyState :empty-state="emptyState" />
      <AposAreaMenu
        @add="insert"
        :context-menu-options="contextMenuOptions"
        :empty="true"
        :index="0"
        :widget-options="options.widgets"
        :max-reached="maxReached"
      />
    </div>
    <div
      class="apos-areas-widgets-list"
      :class="{'is-dragging': isDragging }"
    >
      <draggable
        class="apos-slat-list"
        tag="div"
        role="list"
        :list="next"
        @start="dragStart"
        @end="dragEnd"
        id="weln"
        handle="[data-drag]"
        :group="{
          name: 'hiii',
          pull: true,
          put: true
        }"
      >
        <AposAreaWidget
          v-for="(widget, i) in next"
          :key="i"
          :area-id="areaId"
          :widget="widget"
          :i="i"
          :editing="editing[widget._id] || false"
          :options="options"
          :next="next"
          :doc-id="docId"
          :context-menu-options="contextMenuOptions"
          :field-id="fieldId"
          :widget-hovered="hoveredWidget"
          :widget-focused="focusedWidget"
          :max-reached="maxReached"
          @done="done"
          @up="up"
          @down="down"
          @remove="remove"
          @edit="edit"
          @close="close"
          @update="update"
          @insert="insert"
        />
      </draggable>
    </div>
  </div>
</template>

<script>

import Vue from 'apostrophe/vue';
import cuid from 'cuid';
import draggable from 'vuedraggable';
import klona from 'klona';

export default {
  name: 'AposAreaEditor',
  components: {
    draggable
  },
  props: {
    docId: {
      type: String,
      default: null
    },
    docType: {
      type: String,
      default: null
    },
    id: {
      type: String,
      required: true
    },
    fieldId: {
      type: String,
      required: true
    },
    options: {
      type: Object,
      default() {
        return {};
      }
    },
    items: {
      type: Array,
      default() {
        return [];
      }
    },
    choices: {
      type: Array,
      required: true
    }
  },
  emits: [ 'changed' ],
  data() {
    const validItems = this.items.filter(item => {
      if (!window.apos.modules[`${item.type}-widget`]) {
        console.warn(`The widget type ${item.type} exists in the content but is not configured.`);
      }
      return window.apos.modules[`${item.type}-widget`];
    });

    return {
      areaId: cuid(),
      next: validItems,
      editing: {},
      hoveredWidget: null,
      focusedWidget: null,
      contextMenuOptions: {
        menu: this.choices
      },
      emptyState: {
        message: 'Add your content here'
      },
      isDragging: false
    };
  },
  computed: {
    dragOptions() {
      return {
        animation: 0,
        sort: false,
        handle: '[data-move]',
        group: {
          name: this.areaId,
          put: [ this.areaId ]
        }
        // disabled: true
      };
    },
    moduleOptions() {
      return window.apos.area;
    },
    types() {
      return Object.keys(this.options.widgets);
    },
    maxReached() {
      return this.options.max && this.next.length >= this.options.max;
    }
  },
  watch: {
    next() {
      if (!this.docId) {
        // For the benefit of AposInputArea which is the
        // direct parent when we are not editing on-page
        this.$emit('changed', {
          items: this.next
        });
      } else {
        // For the benefit of all other area editors on-page
        // which may have this one as a sub-area in some way, and
        // mistakenly think they know its contents have not changed
        apos.bus.$emit('area-updated', {
          _id: this.id,
          items: this.next
        });
      }
    }
  },
  mounted() {
    if (this.docId) {
      this.areaUpdatedHandler = (area) => {
        for (const item of this.next) {
          if (this.patchSubobject(item, area)) {
            break;
          }
        }
      };
      apos.bus.$on('area-updated', this.areaUpdatedHandler);
      apos.bus.$on('widget-hover', this.updateWidgetHovered);
      apos.bus.$on('widget-focus', this.updateWidgetFocused);
    }
  },
  beforeDestroy() {
    if (this.areaUpdatedHandler) {
      apos.bus.$off('area-updated', this.areaUpdatedHandler);
      apos.bus.$off('widget-hover', this.updateWidgetHovered);
      apos.bus.$off('widget-focus', this.updateWidgetFocused);
    }
  },
  methods: {
    dragStart() {
      this.isDragging = true;
    },
    dragEnd() {
      this.isDragging = false;
    },
    updateWidgetHovered(widgetId) {
      this.hoveredWidget = widgetId;
    },
    updateWidgetFocused(widgetId) {
      this.focusedWidget = widgetId;
    },
    async up(i) {
      if (this.docId) {
        await apos.http.patch(`${apos.doc.action}/${this.docId}`, {
          busy: true,
          body: {
            $move: {
              [`@${this.id}.items`]: {
                $item: this.next[i]._id,
                $before: this.next[i - 1]._id
              }
            }
          }
        });
      }
      this.next = [
        ...this.next.slice(0, i - 1),
        this.next[i],
        this.next[i - 1],
        ...this.next.slice(i + 1)
      ];
    },
    async down(i) {
      if (this.docId) {
        await apos.http.patch(`${apos.doc.action}/${this.docId}`, {
          busy: true,
          body: {
            $move: {
              [`@${this.id}.items`]: {
                $item: this.next[i]._id,
                $after: this.next[i + 1]._id
              }
            }
          }
        });
      }
      this.next = [
        ...this.next.slice(0, i),
        this.next[i + 1],
        this.next[i],
        ...this.next.slice(i + 2)
      ];
    },
    async remove(i) {
      if (this.docId) {
        await apos.http.patch(`${apos.doc.action}/${this.docId}`, {
          busy: true,
          body: {
            $pullAllById: {
              [`@${this.id}.items`]: [ this.next[i]._id ]
            }
          }
        });
      }
      this.next = [
        ...this.next.slice(0, i),
        ...this.next.slice(i + 1)
      ];
    },
    edit(i) {
      Vue.set(this.editing, this.next[i]._id, !this.editing[this.next[i]._id]);
    },
    clone(index) {
      const widget = klona(this.next[index]);
      delete widget._id;
      this.insert({
        widget,
        index
      });
    },
    async update(widget) {
      if (this.docId) {
        await apos.http.patch(`${apos.doc.action}/${this.docId}`, {
          busy: 'contextual',
          body: {
            [`@${widget._id}`]: widget
          }
        });
      }
      const index = this.next.findIndex(w => w._id === widget._id);
      this.next = [
        ...this.next.slice(0, index),
        widget,
        ...this.next.slice(index + 1)
      ];
      if (!this.widgetIsContextual(widget.type)) {
        this.editing[widget._id] = false;
      }
    },
    async close(widget) {
      if (!this.widgetIsContextual(widget.type)) {
        this.editing[widget._id] = false;
      }
    },
    async done(widget) {
      if (!this.widgetIsContextual(widget.type)) {
        this.editing[widget._id] = false;
      }
    },
    async insert(e) {
      const widget = e.widget;
      if (!widget._id) {
        widget._id = cuid();
      }
      const push = {
        $each: [ widget ]
      };
      if (e.index < this.next.length) {
        push.$before = this.next[e.index]._id;
      }
      if (this.docId) {
        await apos.http.patch(`${apos.doc.action}/${this.docId}`, {
          busy: true,
          body: {
            $push: {
              [`@${this.id}.items`]: push
            }
          }
        });
      }
      this.next = [
        ...this.next.slice(0, e.index),
        widget,
        ...this.next.slice(e.index)
      ];
      if (this.widgetIsContextual(widget.type)) {
        this.edit(e.index);
      }
    },
    widgetComponent(type) {
      return this.moduleOptions.components.widgets[type];
    },
    widgetEditorComponent(type) {
      return this.moduleOptions.components.widgetEditors[type];
    },
    widgetIsContextual(type) {
      return this.moduleOptions.widgetIsContextual[type];
    },
    // Recursively seek `subObject` within `object`, based on whether
    // its _id matches that of a sub-object of `object`. If found,
    // replace that sub-object with `subObject` and return `true`.
    patchSubobject(object, subObject) {
      let result;
      for (const [ key, val ] of Object.entries(object)) {
        if (val && typeof val === 'object') {
          if (val._id === subObject._id) {
            object[key] = subObject;
            return true;
          }
          result = this.patchSubobject(val, subObject);
          if (result) {
            return result;
          }
        }
      }
    }
  }
};

</script>

<style lang="scss" scoped>
  .apos-drop-indicator {
    margin: 5px 0;
    opacity: 0;
    transition: all 0.2s ease;
    background-color: var(--a-primary);
  }

  .is-dragging .apos-drop-indicator {
    opacity: 0.3;
    height: 10px;
    margin: 0;
  }
  .apos-empty-area {
    display: flex;
    padding: 30px;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    min-height: 50px;
    background-color: var(--a-base-10);
    border: 2px dotted var(--a-primary);
  }

  .apos-area-widget-wrapper {
    position: relative;
  }

  .apos-areas-widgets-list {
    display: flex;
    flex-direction: column;
    padding-left: 0;
    margin-bottom: 0;
  }

</style>

/* stylelint-enable */
